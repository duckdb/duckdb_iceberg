/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This code was generated by avrogencpp 1.13.0-SNAPSHOT. Do not edit.*/

#ifndef MANIFEST_ENTRY_HH_2043678367_H
#define MANIFEST_ENTRY_HH_2043678367_H

#include "avro/Decoder.hh"
#include "avro/Encoder.hh"
#include "avro/Specific.hh"
#include "boost/any.hpp"

#include <sstream>
#include <utility>

struct k126_v127 {
	int32_t key;
	std::vector<uint8_t> value;
	k126_v127() : key(int32_t()), value(std::vector<uint8_t>()) {
	}
};

struct manifest_entry_json_Union__0__ {
private:
	size_t idx_;
	boost::any value_;

public:
	/** enum representing union branches as returned by the idx() function */
	enum class Branch : size_t {
		null = 0,
		array = 1,
	};
	size_t idx() const {
		return idx_;
	}
	Branch branch() const {
		return static_cast<Branch>(idx_);
	}
	bool is_null() const {
		return (idx_ == 0);
	}
	void set_null() {
		idx_ = 0;
		value_ = boost::any();
	}
	const std::vector<k126_v127> &get_array() const;
	std::vector<k126_v127> &get_array();
	void set_array(const std::vector<k126_v127> &v);
	void set_array(std::vector<k126_v127> &&v);
	manifest_entry_json_Union__0__();
};

struct k129_v130 {
	int32_t key;
	std::vector<uint8_t> value;
	k129_v130() : key(int32_t()), value(std::vector<uint8_t>()) {
	}
};

struct manifest_entry_json_Union__1__ {
private:
	size_t idx_;
	boost::any value_;

public:
	/** enum representing union branches as returned by the idx() function */
	enum class Branch : size_t {
		null = 0,
		array = 1,
	};
	size_t idx() const {
		return idx_;
	}
	Branch branch() const {
		return static_cast<Branch>(idx_);
	}
	bool is_null() const {
		return (idx_ == 0);
	}
	void set_null() {
		idx_ = 0;
		value_ = boost::any();
	}
	const std::vector<k129_v130> &get_array() const;
	std::vector<k129_v130> &get_array();
	void set_array(const std::vector<k129_v130> &v);
	void set_array(std::vector<k129_v130> &&v);
	manifest_entry_json_Union__1__();
};

struct r2 {
	typedef manifest_entry_json_Union__0__ lower_bounds_t;
	typedef manifest_entry_json_Union__1__ upper_bounds_t;
	int32_t content;
	std::string file_path;
	std::string file_format;
	int64_t record_count;
	lower_bounds_t lower_bounds;
	upper_bounds_t upper_bounds;
	r2()
	    : content(int32_t()), file_path(std::string()), file_format(std::string()), record_count(int64_t()),
	      lower_bounds(lower_bounds_t()), upper_bounds(upper_bounds_t()) {
	}
};

struct manifest_entry {
	int32_t status;
	r2 data_file;
	manifest_entry() : status(int32_t()), data_file(r2()) {
	}
};

inline const std::vector<k126_v127> &manifest_entry_json_Union__0__::get_array() const {
	if (idx_ != 1) {
		throw avro::Exception("Invalid type for union manifest_entry_json_Union__0__");
	}
	return *boost::any_cast<std::vector<k126_v127>>(&value_);
}

inline std::vector<k126_v127> &manifest_entry_json_Union__0__::get_array() {
	if (idx_ != 1) {
		throw avro::Exception("Invalid type for union manifest_entry_json_Union__0__");
	}
	return *boost::any_cast<std::vector<k126_v127>>(&value_);
}

inline void manifest_entry_json_Union__0__::set_array(const std::vector<k126_v127> &v) {
	idx_ = 1;
	value_ = v;
}

inline void manifest_entry_json_Union__0__::set_array(std::vector<k126_v127> &&v) {
	idx_ = 1;
	value_ = std::move(v);
}

inline const std::vector<k129_v130> &manifest_entry_json_Union__1__::get_array() const {
	if (idx_ != 1) {
		throw avro::Exception("Invalid type for union manifest_entry_json_Union__1__");
	}
	return *boost::any_cast<std::vector<k129_v130>>(&value_);
}

inline std::vector<k129_v130> &manifest_entry_json_Union__1__::get_array() {
	if (idx_ != 1) {
		throw avro::Exception("Invalid type for union manifest_entry_json_Union__1__");
	}
	return *boost::any_cast<std::vector<k129_v130>>(&value_);
}

inline void manifest_entry_json_Union__1__::set_array(const std::vector<k129_v130> &v) {
	idx_ = 1;
	value_ = v;
}

inline void manifest_entry_json_Union__1__::set_array(std::vector<k129_v130> &&v) {
	idx_ = 1;
	value_ = std::move(v);
}

inline manifest_entry_json_Union__0__::manifest_entry_json_Union__0__() : idx_(0) {
}
inline manifest_entry_json_Union__1__::manifest_entry_json_Union__1__() : idx_(0) {
}
namespace avro {
template <>
struct codec_traits<k126_v127> {
	static void encode(Encoder &e, const k126_v127 &v) {
		avro::encode(e, v.key);
		avro::encode(e, v.value);
	}
	static void decode(Decoder &d, k126_v127 &v) {
		if (avro::ResolvingDecoder *rd = dynamic_cast<avro::ResolvingDecoder *>(&d)) {
			const std::vector<size_t> fo = rd->fieldOrder();
			for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it) {
				switch (*it) {
				case 0:
					avro::decode(d, v.key);
					break;
				case 1:
					avro::decode(d, v.value);
					break;
				default:
					break;
				}
			}
		} else {
			avro::decode(d, v.key);
			avro::decode(d, v.value);
		}
	}
};

template <>
struct codec_traits<manifest_entry_json_Union__0__> {
	static void encode(Encoder &e, manifest_entry_json_Union__0__ v) {
		e.encodeUnionIndex(v.idx());
		switch (v.idx()) {
		case 0:
			e.encodeNull();
			break;
		case 1:
			avro::encode(e, v.get_array());
			break;
		}
	}
	static void decode(Decoder &d, manifest_entry_json_Union__0__ &v) {
		size_t n = d.decodeUnionIndex();
		if (n >= 2) {
			throw avro::Exception("Union index too big");
		}
		switch (n) {
		case 0:
			d.decodeNull();
			v.set_null();
			break;
		case 1: {
			std::vector<k126_v127> vv;
			avro::decode(d, vv);
			v.set_array(std::move(vv));
		} break;
		}
	}
};

template <>
struct codec_traits<k129_v130> {
	static void encode(Encoder &e, const k129_v130 &v) {
		avro::encode(e, v.key);
		avro::encode(e, v.value);
	}
	static void decode(Decoder &d, k129_v130 &v) {
		if (avro::ResolvingDecoder *rd = dynamic_cast<avro::ResolvingDecoder *>(&d)) {
			const std::vector<size_t> fo = rd->fieldOrder();
			for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it) {
				switch (*it) {
				case 0:
					avro::decode(d, v.key);
					break;
				case 1:
					avro::decode(d, v.value);
					break;
				default:
					break;
				}
			}
		} else {
			avro::decode(d, v.key);
			avro::decode(d, v.value);
		}
	}
};

template <>
struct codec_traits<manifest_entry_json_Union__1__> {
	static void encode(Encoder &e, manifest_entry_json_Union__1__ v) {
		e.encodeUnionIndex(v.idx());
		switch (v.idx()) {
		case 0:
			e.encodeNull();
			break;
		case 1:
			avro::encode(e, v.get_array());
			break;
		}
	}
	static void decode(Decoder &d, manifest_entry_json_Union__1__ &v) {
		size_t n = d.decodeUnionIndex();
		if (n >= 2) {
			throw avro::Exception("Union index too big");
		}
		switch (n) {
		case 0:
			d.decodeNull();
			v.set_null();
			break;
		case 1: {
			std::vector<k129_v130> vv;
			avro::decode(d, vv);
			v.set_array(std::move(vv));
		} break;
		}
	}
};

template <>
struct codec_traits<r2> {
	static void encode(Encoder &e, const r2 &v) {
		avro::encode(e, v.content);
		avro::encode(e, v.file_path);
		avro::encode(e, v.file_format);
		avro::encode(e, v.record_count);
		avro::encode(e, v.lower_bounds);
		avro::encode(e, v.upper_bounds);
	}
	static void decode(Decoder &d, r2 &v) {
		if (avro::ResolvingDecoder *rd = dynamic_cast<avro::ResolvingDecoder *>(&d)) {
			const std::vector<size_t> fo = rd->fieldOrder();
			for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it) {
				switch (*it) {
				case 0:
					avro::decode(d, v.content);
					break;
				case 1:
					avro::decode(d, v.file_path);
					break;
				case 2:
					avro::decode(d, v.file_format);
					break;
				case 3:
					avro::decode(d, v.record_count);
					break;
				case 4:
					avro::decode(d, v.lower_bounds);
					break;
				case 5:
					avro::decode(d, v.upper_bounds);
					break;
				default:
					break;
				}
			}
		} else {
			avro::decode(d, v.content);
			avro::decode(d, v.file_path);
			avro::decode(d, v.file_format);
			avro::decode(d, v.record_count);
			avro::decode(d, v.lower_bounds);
			avro::decode(d, v.upper_bounds);
		}
	}
};

template <>
struct codec_traits<manifest_entry> {
	static void encode(Encoder &e, const manifest_entry &v) {
		avro::encode(e, v.status);
		avro::encode(e, v.data_file);
	}
	static void decode(Decoder &d, manifest_entry &v) {
		if (avro::ResolvingDecoder *rd = dynamic_cast<avro::ResolvingDecoder *>(&d)) {
			const std::vector<size_t> fo = rd->fieldOrder();
			for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it) {
				switch (*it) {
				case 0:
					avro::decode(d, v.status);
					break;
				case 1:
					avro::decode(d, v.data_file);
					break;
				default:
					break;
				}
			}
		} else {
			avro::decode(d, v.status);
			avro::decode(d, v.data_file);
		}
	}
};

} // namespace avro
#endif